module core
//? The following declarations describe fundamental properties of types and their values.
//? They tend to be inherent which makes them opt-out and derived with a set of requirements.
//?
//? It is often possible to forcibly implement them, but that is almost always unsafe.
//? The option is there for low level primitives that are able to preserve properties
//? like thread safety despite breaking the inherent requirements, but that's something
//? the language cannot prove thus making it highly unsafe to attempt.

/// A value which can be implicitly copied instead of being moved.
///
/// Copyability is inherent, any type which satisfies the requirements is copyable.
/// Implementing it manually is unsafe and almost certainly unsound.
pub unsafe inherent category Copyable
where
    Self: not Deinitializable,
    (Self::Components: Copyable)...

/// Allow copyable types to be copied implicitly.
///
/// This extension is safe because it's constrained by copyability restrictions.
unsafe extend Any: #ImplicitlyCopyable where Self: Copyable

/// A value which has deinitialization logic.
pub unsafe inherent category Deinitializable where Self.deinit != nil

/// A value which can be moved across synchronization boundaries.
pub unsafe inherent category Sendable

/// A value which can be cloned which is a more general form of opt-in copying.
///
/// Unlike copying, cloning can be expensive depending on the type it is performed on.
pub category Cloneable {
    /// Returns an exact copy of the value.
    fun clone(&self) -> Self
}

/// Make all copyable values cloneable.
extend Any: Cloneable where Self: Copyable {
    pub fun clone(&self) -> Self {
        self
    }
}

/// Derive cloning structurally.
extend (Element...): Cloneable where (Element: Cloneable)... {
    pub fun clone(&self) -> Self {
        let (&elements...) = self
        (elements.clone(), ...)
    }
}
